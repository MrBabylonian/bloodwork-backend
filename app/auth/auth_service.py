"""
Core authentication service for veterinary bloodwork analysis system.

This module provides comprehensive authentication functionality for both
regular users and administrators using human-readable IDs instead of ObjectIds.

Features:
- User registration with role-based ID generation (VET-001, TEC-001)
- JWT token management with human-readable user references
- Role-based access control with Admin/User separation
- Password security validation and hashing
- Comprehensive audit logging and error handling

Last updated: 2025-06-20
Author: Bedirhan Gilgiler
"""

import uuid
from datetime import datetime, timezone

from app.auth.auth_config import AuthConfig
from app.auth.password_service import PasswordService
from app.auth.token_service import TokenService
from app.models.database_models import (
    Admin,
    ApprovalStatus,
    RefreshToken,
    User,
    UserRole,
)
from app.repositories.admin_repository import AdminRepository
from app.repositories.refresh_token_repository import RefreshTokenRepository
from app.repositories.user_repository import UserRepository
from app.utils.logger_utils import ApplicationLogger


class AuthService:
    """
    Core authentication service for the veterinary bloodwork analysis system.

    Handles user registration, login, token refresh, and authentication validation
    for both regular users (veterinarians, technicians) and administrators.

    Key Features:
    - Unified authentication for Admin and User models
    - JWT token management with automatic refresh
    - Role-based access control
    - Password security validation
    - Comprehensive audit logging
    """

    def __init__(self, user_repo: UserRepository, admin_repo: AdminRepository,
                 refresh_token_repo: RefreshTokenRepository, config: AuthConfig | None = None):
        """Initialize authentication service with required repositories and configuration."""
        self.user_repo = user_repo
        self.admin_repo = admin_repo
        self.refresh_token_repo = refresh_token_repo
        self.config = config or AuthConfig()
        self.password_service = PasswordService()
        self.token_service = TokenService(self.config)
        self.logger = ApplicationLogger.get_logger(__name__)

    async def register_user(self, username: str, email: str, password: str,
                            role: UserRole, profile: dict | None = None) -> User | None:
        """
        Register a new veterinary user with pending approval status.

        Args:
            username: Unique username for the user
            email: User's email address
            password: Plain text password (will be hashed)
            role: User role (VETERINARIAN or TECHNICIAN)
            profile: Optional user profile information

        Returns:
            Created User object or None if registration failed
        """
        try:
            # Validate password strength
            if not self.password_service.is_valid_password(password, self.config.password_min_length):
                self.logger.warning(
                    f"Registration failed - weak password: {username}")
                return None

            # NOTE: This method creates user without user_id - repository will generate it
            # Create new user with secure password hash
            user = User(
                _id="",  # Will be generated by repository
                username=username,
                email=email,
                hashed_password=self.password_service.hash_password(password),
                role=role,
                profile=profile or {}
            )

            created_user = await self.user_repo.create(user)
            if created_user:
                self.logger.info(f"New user registered: {username} ({role})")

            return created_user

        except Exception as e:
            self.logger.error(f"Registration error: {e}")
            return None

    async def login(self, username: str, password: str,
                    device_info: str | None = None, ip_address: str | None = None) -> dict | None:
        """
        Authenticate user and generate JWT tokens.

        Supports both regular users and administrators with appropriate status checks.
        Regular users must be approved, admins only need to be active.

        Args:
            username: User's username
            password: Plain text password
            device_info: Optional device information for audit
            ip_address: Optional IP address for audit

        Returns:
            Dictionary with tokens and user info, or None if login failed
        """
        try:
            # Search in users collection first, then admins
            user = await self.user_repo.get_by_username(username)
            is_admin = False

            if not user:
                user = await self.admin_repo.get_by_username(username)
                is_admin = True

            if not user:
                self.logger.warning(
                    f"Login failed - user not found: {username}")
                return None

            # Validate user status based on type
            if is_admin:
                if not user.is_active:
                    self.logger.warning(
                        f"Login blocked - inactive admin: {username}")
                    return None
            else:
                # Regular users need approval and active status
                from app.models.database_models import User
                if isinstance(user, User) and user.approval_status != ApprovalStatus.APPROVED:
                    self.logger.warning(
                        f"Login blocked - unapproved user: {username}")
                    return None
                if not user.is_active:
                    self.logger.warning(
                        f"Login blocked - inactive user: {username}")
                    return None

            # Verify password
            if not self.password_service.verify_password(password, user.hashed_password):
                self.logger.warning(
                    f"Login failed - invalid password: {username}")
                return None

            # Ensure user has valid ID and get the appropriate ID field
            from app.models.database_models import Admin, User
            if isinstance(user, Admin):
                user_id = user.admin_id
            elif isinstance(user, User):
                user_id = user.user_id
            else:
                self.logger.error(
                    f"Login error - unknown user type: {username}")
                return None

            if not user_id:
                self.logger.error(f"Login error - missing user ID: {username}")
                return None

            # Generate JWT tokens
            access_token = self.token_service.create_access_token(
                user_id=user_id,
                username=user.username,
                role=user.role
            )

            refresh_token = self.token_service.create_refresh_token(
                user_id=user_id,
                username=user.username
            )

            # Store refresh token with expiration and audit info
            refresh_expires_at = datetime.now(
                timezone.utc) + self.config.refresh_token_expire_time

            # Create RefreshToken model object
            token_id = f"TKN-{str(uuid.uuid4())[:8].upper()}"
            token_object = RefreshToken(
                _id=token_id,
                user_id=user_id,
                token_hash=refresh_token,  # This will be hashed by the repository
                expires_at=refresh_expires_at,
                device_info=device_info,
                ip_address=ip_address
            )

            await self.refresh_token_repo.create(token_object)

            # Update last login timestamp
            from app.models.database_models import Admin, User
            if isinstance(user, Admin):
                await self.admin_repo.update_last_login(user_id)
                user_type = "admin"
            elif isinstance(user, User):
                await self.user_repo.update_last_login(user_id)
                user_type = "user"
            else:
                user_type = "unknown"
            self.logger.info(f"Login successful: {username} ({user_type})")

            return {
                "access_token": access_token,
                "refresh_token": refresh_token,
                "token_type": "bearer",
                "expires_in": self.config.access_token_expire_minutes * 60,
                "user": {
                    "id": user_id,
                    "username": user.username,
                    "email": user.email,
                    "role": user.role,
                    "profile": user.profile
                }
            }

        except Exception as e:
            self.logger.error(f"Login error: {e}")
            return None

    async def refresh_access_token(self, refresh_token: str) -> dict | None:
        """
        Generate new access token using valid refresh token.

        Args:
            refresh_token: JWT refresh token

        Returns:
            Dictionary with new access token or None if refresh failed
        """
        try:
            # Verify and validate refresh token
            payload = self.token_service.verify_token(refresh_token)
            if not payload or not self.token_service.is_refresh_token(payload):
                self.logger.warning("Token refresh failed - invalid token")
                return None

            # Check if token exists in database
            token_record = await self.refresh_token_repo.get_by_token_hash(refresh_token)
            if not token_record or not token_record.is_active:
                self.logger.warning("Token refresh failed - expired/revoked")
                return None

            # Extract and validate user
            user_id = self.token_service.get_user_id_from_payload(payload)
            if not user_id:
                self.logger.warning("Token refresh failed - no user ID")
                return None

            # Try to find user in both collections
            user = await self.user_repo.get_by_id(user_id)

            if not user:
                user = await self.admin_repo.get_by_id(user_id)

            if not user:
                self.logger.warning(
                    f"Token refresh blocked - user not found: {user_id}")
                return None

            # Validate user status based on type
            from app.models.database_models import Admin, User
            if isinstance(user, Admin):
                if not user.is_active:
                    self.logger.warning(
                        f"Token refresh blocked - inactive admin: {user_id}")
                    return None
                actual_user_id = user.admin_id
            elif isinstance(user, User):
                if not user.is_active or user.approval_status != ApprovalStatus.APPROVED:
                    self.logger.warning(
                        f"Token refresh blocked - user inactive: {user_id}")
                    return None
                actual_user_id = user.user_id
            else:
                self.logger.error(
                    f"Token refresh error - unknown user type: {user_id}")
                return None

            if not actual_user_id:
                self.logger.error(
                    f"Token refresh error - missing ID: {user_id}")
                return None

            # Generate new access token
            access_token = self.token_service.create_access_token(
                user_id=actual_user_id,
                username=user.username,
                role=user.role
            )

            self.logger.info(f"Token refreshed: {user.username}")
            return {
                "access_token": access_token,
                "token_type": "bearer",
                "expires_in": self.config.access_token_expire_minutes * 60
            }

        except Exception as e:
            self.logger.error(f"Token refresh error: {e}")
            return None

    async def logout(self, refresh_token: str) -> bool:
        """
        Logout user by invalidating their refresh token.

        Args:
            refresh_token: JWT refresh token to invalidate

        Returns:
            True if logout successful, False otherwise
        """
        try:
            success = await self.refresh_token_repo.invalidate_by_hash(refresh_token)
            if success:
                self.logger.info("Logout successful")
            return success

        except Exception as e:
            self.logger.error(f"Logout error: {e}")
            return False

    async def logout_all_devices(self, user_id: str) -> bool:
        """
        Logout user from all devices by invalidating all their refresh tokens.

        Args:
            user_id: User's unique identifier

        Returns:
            True if all tokens invalidated successfully, False otherwise
        """
        try:
            success = await self.refresh_token_repo.invalidate_all_for_user(user_id)
            if success:
                self.logger.info(f"All devices logged out: {user_id}")
            return success

        except Exception as e:
            self.logger.error(f"Multi-device logout error: {e}")
            return False

    async def verify_access_token(self, token: str) -> dict | None:
        """
        Verify JWT access token and return user information.

        Legacy method - use get_authenticated_user for new code.

        Args:
            token: JWT access token

        Returns:
            Dictionary with user info or None if verification failed
        """
        try:
            # Verify token format and signature
            payload = self.token_service.verify_token(token)
            if not payload:
                self.logger.warning(
                    "Token verification failed - invalid format")
                return None

            if not self.token_service.is_access_token(payload):
                self.logger.warning(
                    "Token verification failed - not access token")
                return None

            # Extract user ID and validate user exists
            user_id = self.token_service.get_user_id_from_payload(payload)
            if not user_id:
                self.logger.warning("Token verification failed - no user ID")
                return None

            # Check user collections (users first, then admins)
            user = await self.user_repo.get_by_id(user_id)
            if not user:
                admin = await self.admin_repo.get_by_id(user_id)
                if not admin:
                    self.logger.warning(
                        f"Token verification failed - user not found: {user_id}")
                    return None
                user = admin

            # Validate user status
            if not user.is_active:
                self.logger.warning(
                    f"Token verification failed - inactive user: {user_id}")
                return None

            # Check approval status for regular users only
            from app.models.database_models import Admin, User

            if isinstance(user, Admin):
                self.logger.debug(f"Admin authenticated: {user.username}")
            elif isinstance(user, User):
                if user.approval_status != ApprovalStatus.APPROVED:
                    self.logger.warning(
                        f"Token verification failed - unapproved user: {user_id}")
                    return None
                self.logger.debug(f"User authenticated: {user.username}")
            else:
                self.logger.warning(
                    f"Token verification failed - unknown user type: {user_id}")
                return None

            return {
                "user_id": user_id,
                "username": self.token_service.get_username_from_payload(payload),
                "role": self.token_service.get_role_from_payload(payload)
            }

        except Exception as e:
            self.logger.error(f"Token verification error: {e}")
            return None

    async def get_authenticated_user(self, token: str) -> User | Admin | None:
        """
        Get the authenticated user from a JWT token.

        This method validates the token and returns the corresponding user object
        from either the User or Admin collection based on the token contents.

        Args:
            token: JWT access token

        Returns:
            User or Admin object if valid, None otherwise
        """
        try:
            # Verify and decode the token
            payload = self.token_service.verify_token(token)
            if not payload:
                return None

            user_id = self.token_service.get_user_id_from_payload(payload)
            if not user_id:
                return None

            # Try to get user from users collection first
            user = await self.user_repo.get_by_id(user_id)
            if user:
                return user

            # If not found in users, try admins collection
            admin = await self.admin_repo.get_by_id(user_id)
            if admin:
                return admin

            return None

        except Exception as e:
            self.logger.error(f"Error getting authenticated user: {e}")
            return None

    async def change_password(self, user_id: str, current_password: str, new_password: str) -> bool:
        """
        Change user password after validating current password.

        This method provides secure password change functionality by:
        1. Validating the current password
        2. Checking new password strength
        3. Updating the password hash in the database
        4. Supporting both User and Admin accounts

        Args:
            user_id: User or Admin ID (e.g., VET-001, ADM-001)
            current_password: Current password for verification
            new_password: New password to set

        Returns:
            True if password changed successfully, False otherwise
        """
        try:
            # Find the user in either collection
            user = await self.user_repo.get_by_id(user_id)
            is_admin = False

            if not user:
                user = await self.admin_repo.get_by_id(user_id)
                is_admin = True

            if not user:
                self.logger.warning(
                    f"Password change failed - user not found: {user_id}")
                return False

            # Verify current password
            if not self.password_service.verify_password(current_password, user.hashed_password):
                self.logger.warning(
                    f"Password change failed - invalid current password: {user_id}")
                return False

            # Validate new password strength
            if not self.password_service.is_valid_password(new_password, self.config.password_min_length):
                self.logger.warning(
                    f"Password change failed - weak new password: {user_id}")
                return False

            # Hash the new password
            new_hashed_password = self.password_service.hash_password(
                new_password)

            # Update password in appropriate repository
            if is_admin:
                success = await self.admin_repo.update_password(user_id, new_hashed_password)
            else:
                success = await self.user_repo.update_password(user_id, new_hashed_password)

            if success:
                self.logger.info(
                    f"Password changed successfully for user: {user_id}")
                return True
            else:
                self.logger.error(
                    f"Password change failed - database update failed: {user_id}")
                return False

        except Exception as e:
            self.logger.error(f"Password change error: {e}")
            return False
